package main

import (
	"encoding/json"
	"errors"
	"log"
	"net/http"
	"path"
	"regexp"
	"time"

	"github.com/ellenkorbes/chatty/secrets"

	mgo "gopkg.in/mgo.v2"
	"gopkg.in/mgo.v2/bson"
)

/*

888
888
888
888888 888  888 88888b.   .d88b.  .d8888b
888    888  888 888 "88b d8P  Y8b 88K
888    888  888 888  888 88888888 "Y8888b.
Y88b.  Y88b 888 888 d88P Y8b.          X88
 "Y888  "Y88888 88888P"   "Y8888   88888P'
            888 888
       Y8b d88P 888
        "Y88P"  888

*/

// User
type User struct {
	ID        bson.ObjectId `json:"id"        bson:"_id,omitempty"` // The unique indentifier of the object. Read only.
	Budget    int           `json:"budget"    bson:"budget"`        // The remaining budget to send messages. Read only.
	Name      string        `json:"name"      bson:"name"`          // The human readable name of the user.
	Username  string        `json:"username"  bson:"username"`      // The unique name of the user. '^[a-z][a-z_\.\-0-9]*$'.
	CreatedAt time.Time     `json:"createdAt" bson:"createdAt"`     // The UTC date and time user has been created. Read only.
	UpdatedAt time.Time     `json:"updatedAt" bson:"updatedAt"`     // The UTC date and time user has been updated. Read only.
}

// Messages
type Messages struct {
	Entries []Message `json:"messages" bson:"messages"`
}

// Message
type Message struct {
	ID     bson.ObjectId `json:"id"      bson:"_id,omitempty"` // The unique indentifier of the object. Read only.
	From   string        `json:"from"    bson:"from"`          // The sender user id.
	To     string        `json:"to"      bson:"to"`            // The recipient user id.
	Body   string        `json:"body"    bson:"body"`          // The message body content. Length: 1–280.
	SentAt time.Time     `json:"sentAt"  bson:"sentAt"`        // The UTC date and time message was sent. Read only.
}

// Problem
type Problem struct {
	Type     string   `json:"type" bson:"type"`         // An absolute URI that identifies the problem type. When dereferenced, it SHOULD provide human-readable documentation for the problem type (e.g., using HTML).
	Title    string   `json:"title" bson:"title"`       // A short, summary of the problem type. Written in english and readable for engineers (usually not suited for non technical stakeholders and not localized).
	Status   int      `json:"status" bson:"status"`     // The HTTP status code generated by the origin server for this occurrence of the problem. 100–599.
	Detail   string   `json:"detail" bson:"detail"`     // A human readable explanation specific to this occurrence of the problem.
	Details  []string `json:"details" bson:"details"`   // A list of human readable explanation specific to this occurrence of the problem.
	Instance string   `json:"instance" bson:"instance"` // An absolute URI that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
}

func (u *User) MarshalJSON() ([]byte, error) {
	type Alias User
	utc, _ := time.LoadLocation("UTC")
	return json.Marshal(&struct {
		*Alias
		CreatedAt string `json:"createdAt" bson:"createdAt"`
		UpdatedAt string `json:"updatedAt" bson:"updatedAt"`
	}{
		Alias:     (*Alias)(u),
		CreatedAt: u.CreatedAt.In(utc).Format("2006-01-02T15:04:05.999Z0700"),
		UpdatedAt: u.UpdatedAt.In(utc).Format("2006-01-02T15:04:05.999Z0700"),
	})
}

func (u *Message) MarshalJSON() ([]byte, error) {
	type Alias Message
	utc, _ := time.LoadLocation("UTC")
	return json.Marshal(&struct {
		*Alias
		SentAt string `json:"sentAt"  bson:"sentAt"`
	}{
		Alias:  (*Alias)(u),
		SentAt: u.SentAt.In(utc).Format("2006-01-02T15:04:05.999Z0700"),
	})
}

// Dates should follow: 2018-02-19T19:23:57.943Z
// time.Parse(time.RFC3339, "2006-01-02T15:04:05Z")

/*

     888          888             888
     888          888             888
     888          888             888
 .d88888  8888b.  888888  8888b.  88888b.   8888b.  .d8888b   .d88b.
d88" 888     "88b 888        "88b 888 "88b     "88b 88K      d8P  Y8b
888  888 .d888888 888    .d888888 888  888 .d888888 "Y8888b. 88888888
Y88b 888 888  888 Y88b.  888  888 888 d88P 888  888      X88 Y8b.
 "Y88888 "Y888888  "Y888 "Y888888 88888P"  "Y888888  88888P'  "Y8888




*/

// dbInit
func dbInit() *mgo.Session {
	session, err := mgo.Dial(secrets.Mongo())
	if err != nil {
		panic(err)
	}
	return session
}

// dbAddUser
func dbAddUser(db *mgo.Session, user User) error {
	c := db.DB("chatty").C("users")
	count, err := c.Find(bson.M{"username": user.Username}).Limit(1).Count()
	if err != nil {
		return err
	}
	if count > 0 {
		return errors.New("409")
	}
	return c.Insert(user)
	// TODO: look into mgo.IsDup(err) func
}

// dbGetUser
func dbGetUser(db *mgo.Session, user string) (User, error) {
	data := User{}
	err := db.DB("chatty").C("users").Find(bson.M{"username": user}).One(&data)
	if err != nil {
		return data, err
	}
	return data, nil
}

// dbAddMessage
func dbAddMessage(db *mgo.Session, message Message) error {
	c := db.DB("chatty").C("messages")
	return c.Insert(message)
}

// dbGetMessage
func dbGetMessage(db *mgo.Session, id bson.ObjectId) (Message, error) {
	data := Message{}
	err := db.DB("chatty").C("messages").FindId(id).One(&data)
	if err != nil {
		return data, err
	}
	return data, nil
}

// dbDecreaseBudget
func dbDecreaseBudget(db *mgo.Session, sender User) error {
	userCheck := User{}
	budget := mgo.Change{
		Update:    bson.M{"$inc": bson.M{"budget": -1}, "$set": bson.M{"updatedAt": time.Now()}},
		ReturnNew: true,
	}
	_, err := db.DB("chatty").C("users").Find(bson.M{"username": sender.Username}).Apply(budget, &userCheck)
	if err != nil {
		return err
	}
	if sender.Budget-1 != userCheck.Budget {
		return errors.New("budget discrepancy")
	}
	return nil
}

// dbItemsInCollection
func dbItemsInCollection(db *mgo.Session, collection string) (interface{}, error) {
	c := db.DB("chatty").C(collection)
	switch {
	case collection == "users":
		user := User{}
		find := c.Find(bson.M{})
		items := find.Iter()
		response := []User{}
		for items.Next(&user) {
			response = append(response, user)
		}
		return response, nil
	case collection == "messages":
		message := Message{}
		find := c.Find(bson.M{})
		items := find.Iter()
		response := []Message{}
		for items.Next(&message) {
			response = append(response, message)
		}
		return response, nil
	}
	return nil, errors.New("Valid collections are: users, messages.")
}

/*

                          888                    888 888
                          888                    888 888
                          888                    888 888
 .d8888b .d88b.  88888b.  888888 888d888 .d88b.  888 888  .d88b.  888d888
d88P"   d88""88b 888 "88b 888    888P"  d88""88b 888 888 d8P  Y8b 888P"
888     888  888 888  888 888    888    888  888 888 888 88888888 888
Y88b.   Y88..88P 888  888 Y88b.  888    Y88..88P 888 888 Y8b.     888
 "Y8888P "Y88P"  888  888  "Y888 888     "Y88P"  888 888  "Y8888  888




*/

// Controller
type Controller struct {
	DB *mgo.Session
}

// NewController
func NewController(db *mgo.Session) *Controller {
	return &Controller{
		DB: db,
	}
}

// ListAllUsers
func (c *Controller) ListAllUsers(response http.ResponseWriter, request *http.Request) {
	items, err := dbItemsInCollection(c.DB, "users")
	if err != nil {
		log.Println(err)
	}
	response.Header().Set("Content-Type", "application/json")
	json.NewEncoder(response).Encode(&items)
}

// ListAllMessages
func (c *Controller) ListAllMessages(response http.ResponseWriter, request *http.Request) {
	items, err := dbItemsInCollection(c.DB, "messages")
	if err != nil {
		log.Println(err)
	}
	response.Header().Set("Content-Type", "application/json")
	json.NewEncoder(response).Encode(&items)
}

// NewUser
func (c *Controller) NewUser(response http.ResponseWriter, request *http.Request) {
	if request.Method != "POST" {
		http.Error(response, "Please use a POST request.", http.StatusBadRequest)
		log.Println("Non-POST /users request.")
		return
	}
	decoder := json.NewDecoder(request.Body)
	var newUser User
	err := decoder.Decode(&newUser)
	if err != nil {
		response.Header().Set("Content-Type", "application/problem+json")
		http.Error(response, "The user object is bad formatted, missing attributes or has invalid values.", http.StatusBadRequest)
		log.Println("JSON decoding error.", err)
		return
	}
	r, _ := regexp.Compile(`^[a-z][a-z_\.\-0-9]*$`)
	if !r.MatchString(newUser.Username) {
		response.Header().Set("Content-Type", "application/problem+json")
		http.Error(response, "The user object is bad formatted, missing attributes or has invalid values.", http.StatusBadRequest)
		log.Println("Regexp error.", err)
		return
	}
	if newUser.Name == "" {
		response.Header().Set("Content-Type", "application/problem+json")
		http.Error(response, "The user object is bad formatted, missing attributes or has invalid values.", http.StatusBadRequest)
		log.Println("Empty name field.", err)
		return
	}
	newUser.ID = bson.NewObjectId()
	newUser.Budget = 10
	newUser.CreatedAt = time.Now()
	newUser.UpdatedAt = time.Now()
	err = dbAddUser(c.DB, newUser)
	if err != nil {
		response.Header().Set("Content-Type", "application/problem+json")
		if err.Error() == "409" {
			http.Error(response, "The username is already taken by another user.", http.StatusConflict)
			log.Println("Username already taken.", err)
			return
		} else {
			http.Error(response, "Unexpected Error.", http.StatusInternalServerError)
			log.Println("Unknown error in dbAddUser call.", err)
			return
		}
	}
	check, err := dbGetUser(c.DB, newUser.Username)
	if err != nil {
		response.Header().Set("Content-Type", "application/problem+json")
		http.Error(response, "Unexpected Error.", http.StatusInternalServerError)
		log.Println("Error in dbGetUser.", err)
		return
	}
	response.Header().Set("Content-Type", "application/json")
	response.WriteHeader(http.StatusCreated)
	json.NewEncoder(response).Encode(&check)
}

// GetUser
func (c *Controller) GetUser(response http.ResponseWriter, request *http.Request) {
	if request.Method != "GET" {
		http.Error(response, "Please use a GET request.", http.StatusBadRequest)
		log.Println("Non-GET /users/ request.")
		return
	}
	user := path.Base(request.URL.Path)
	query, err := dbGetUser(c.DB, user)
	if err != nil {
		if err.Error() == "not found" {
			response.Header().Set("Content-Type", "application/problem+json")
			http.Error(response, "The user was not found.", http.StatusNotFound)
			log.Println("Error in dbGetUser.", err)
			return
		} else {
			response.Header().Set("Content-Type", "application/problem+json")
			http.Error(response, "Unexpected Error.", http.StatusInternalServerError)
			log.Println("Error in dbGetUser.", err)
			return
		}
	}
	response.Header().Set("Content-Type", "application/json")
	json.NewEncoder(response).Encode(&query)
}

// NewMessage
func (c *Controller) NewMessage(response http.ResponseWriter, request *http.Request) {
	// if request.Method != "POST" {
	// 	http.Error(response, "Please use a POST request.", http.StatusBadRequest)
	// 	log.Println("Non-POST /users request.")
	// 	return
	// }
	decoder := json.NewDecoder(request.Body)
	var newMessage Message
	err := decoder.Decode(&newMessage)
	if err != nil {
		response.Header().Set("Content-Type", "application/problem+json")
		http.Error(response, "The user object is bad formatted, missing attributes or has invalid values.", http.StatusBadRequest)
		log.Println("JSON decoding error.", err)
		return
	}
	if newMessage.To == "" || newMessage.From == "" || newMessage.Body == "" {
		response.Header().Set("Content-Type", "application/problem+json")
		errors := ""
		switch {
		case newMessage.To == "":
			errors += "Message sender is empty. "
		case newMessage.From == "":
			errors += "Message recipient is empty. "
		case newMessage.Body == "":
			errors += "Message has no content. "
		}
		http.Error(response, errors, http.StatusBadRequest)
		log.Println(errors, err)
	}
	sender, err := dbGetUser(c.DB, newMessage.From)
	if err != nil {
		if err.Error() == "not found" {
			response.Header().Set("Content-Type", "application/problem+json")
			http.Error(response, "Sender user not found.", http.StatusNotFound)
			log.Println("Sender user not found.", err)
			return
		} else {
			response.Header().Set("Content-Type", "application/problem+json")
			http.Error(response, "Unexpected error verifying sender.", http.StatusInternalServerError)
			log.Println("Unexpected error verifying sender.", err)
			return
		}
	} else if sender.Budget < 1 {
		response.Header().Set("Content-Type", "application/problem+json")
		http.Error(response, "User budget exceeded.", http.StatusUnauthorized)
		log.Println("User budget exceeded.", err)
		return
	}
	_, err = dbGetUser(c.DB, newMessage.To)
	if err != nil {
		if err.Error() == "not found" {
			response.Header().Set("Content-Type", "application/problem+json")
			http.Error(response, "Recipient user not found.", http.StatusNotFound)
			log.Println("Recipient user not found.", err)
			return
		} else {
			response.Header().Set("Content-Type", "application/problem+json")
			http.Error(response, "Unexpected error verifying recipient.", http.StatusInternalServerError)
			log.Println("Unexpected error verifying recipient.", err)
			return
		}
	}
	newMessage.ID = bson.NewObjectId()
	newMessage.SentAt = time.Now()
	dbAddMessage(c.DB, newMessage)
	if err != nil {
		http.Error(response, "Unexpected Error.", http.StatusInternalServerError)
		log.Println("Unknown error in dbAddMessage call.", err)
		return
	}
	check, err := dbGetMessage(c.DB, newMessage.ID)
	if err != nil {
		response.Header().Set("Content-Type", "application/problem+json")
		http.Error(response, "Unexpected Error.", http.StatusInternalServerError)
		log.Println("Error in dbGetMessage.", err)
		return
	}
	err = dbDecreaseBudget(c.DB, sender)
	if err != nil {
		if err.Error() == "budget discrepancy" {
			log.Println("Budget discrepancy.", err)
		} else {
			log.Println("Unknown error in dbDecreaseBudget call.", err)
		}
	}
	response.Header().Set("Content-Type", "application/json")
	response.WriteHeader(http.StatusCreated)
	json.NewEncoder(response).Encode(&check)
}

// GetMessages
func (c *Controller) GetMessages(response http.ResponseWriter, request *http.Request) {
	// if request.Method != "GET" {
	// 	http.Error(response, "Please use a GET request.", http.StatusBadRequest)
	// 	log.Println("Non-GET /users/ request.")
	// 	return
	// }
	user := request.URL.Query().Get("to")
	messages, err := dbGetMessagesByUser(c.DB, user)
	if err != nil {
		response.Header().Set("Content-Type", "application/problem+json")
		http.Error(response, "Unexpected Error.", http.StatusInternalServerError)
		log.Println("Error in dbGetMessagesByUser.", err)
		return
	}
	response.Header().Set("Content-Type", "application/json")
	json.NewEncoder(response).Encode(&messages)
}

// dbGetMessagesByUser
func dbGetMessagesByUser(db *mgo.Session, user string) (Messages, error) {
	c := db.DB("chatty").C("messages")
	sm := []Message{}
	err := c.Find(bson.M{"to": user}).All(&sm)
	if err != nil {
		return Messages{}, err
	}
	return Messages{sm}, nil
}

// GetMessage
func (c *Controller) GetMessage(response http.ResponseWriter, request *http.Request) {
}

/*

                       d8b
                       Y8P

88888b.d88b.   8888b.  888 88888b.
888 "888 "88b     "88b 888 888 "88b
888  888  888 .d888888 888 888  888
888  888  888 888  888 888 888  888
888  888  888 "Y888888 888 888  888




*/

// MessageRouter
func (c *Controller) MessageRouter(response http.ResponseWriter, request *http.Request) {
	if request.Method == "POST" {
		c.NewMessage(response, request)
	}
	if request.Method == "GET" {
		c.GetMessages(response, request)
	}
}

func main() {

	d := dbInit()
	defer d.Close()
	ctrl := NewController(d)
	mux := http.NewServeMux()
	mux.HandleFunc("/listusers", ctrl.ListAllUsers)  // List all users.
	mux.HandleFunc("/listmsg", ctrl.ListAllMessages) // List all messages.
	mux.HandleFunc("/users", ctrl.NewUser)           // New user.
	mux.HandleFunc("/users/", ctrl.GetUser)          // Get user by username.
	mux.HandleFunc("/messages", ctrl.MessageRouter)  // POST: New message. GET: Get messages for user.
	mux.HandleFunc("/message/", ctrl.GetMessage)     // Get message by id.

	if err := http.ListenAndServe(":8000", mux); err != nil {
		log.Fatal(err)
	}

}

/*

Operations:

Create a user.
POST /users
{
	"name": "Peter Gibbons",
	"username": "peter.gibbons"
  }
Responses:
201 - The user object representation. application/json.
400 - The user object is bad formatted, missing attributes or has invalid values. application/problem+json.
409 - The username is already taken by another user. application/problem+json.
default - Unexpected Error. application/problem+json.

Get a user by id.
GET /users/{id}
Responses:
200 - The user object representation. application/json.
404 - The user was not found. application/problem+json.
default - Unexpected Error. application/problem+json.

Send message from one user to another.
POST /messages
{
	"from": "string",
	"to": "string",
	"body": "string"
}
Responses:
201 - The message object representation. application/json.

List the messages a user has received.
GET /messages?to={user}
Responses:
200 - The message listing representation. application/json.
400 - The request is missing required attributes. application/problem+json.
404 - The user was not found. application/problem+json.
default - Unexpected Error. application/problem+json.

Get a message by id.
GET /message/{id}
Responses:
200 - The message object representation. application/json.
404 - The message was not found. application/problem+json.
default - Unexpected Error. application/problem+json.

*/
