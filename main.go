package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"net/http"
	"time"

	"github.com/ellenkorbes/chatty/secrets"

	mgo "gopkg.in/mgo.v2"
	"gopkg.in/mgo.v2/bson"
)

/*

Types.

*/

type User struct {
	ID        bson.ObjectId `json:"id"        bson:"_id,omitempty"` // The unique indentifier of the object. Read only.
	Budget    int           `json:"budget"    bson:"budget"`        // The remaining budget to send messages. Read only.
	Name      string        `json:"name"      bson:"name"`          // The human readable name of the user.
	Username  string        `json:"username"  bson:"username"`      // The unique name of the user. '^[a-z][a-z_\.\-0-9]*$'.
	CreatedAt time.Time     `json:"createdAt" bson:"createdAt"`     // The UTC date and time user has been created. Read only.
	UpdatedAt time.Time     `json:"updatedAt" bson:"updatedAt"`     // The UTC date and time user has been updated. Read only.
}

// Dates should follow: 2018-02-19T19:23:57.943Z
// time.Parse(time.RFC3339, "2006-01-02T15:04:05Z")

type Messages struct {
	Entries []Message `json:"messages" bson:"messages"`
}

type Message struct {
	ID     bson.ObjectId `json:"id"      bson:"_id,omitempty"` // The unique indentifier of the object. Read only.
	From   string        `json:"from"    bson:"from"`          // The sender user id.
	To     string        `json:"to"      bson:"to"`            // The recipient user id.
	Body   string        `json:"body"    bson:"body"`          // The message body content. Length: 1–280.
	SentAt time.Time     `json:"sentAt"  bson:"sentAt"`        // The UTC date and time message was sent. Read only.
}

type Problem struct {
	Type     string   `json:"type" bson:"type"`         // An absolute URI that identifies the problem type. When dereferenced, it SHOULD provide human-readable documentation for the problem type (e.g., using HTML).
	Title    string   `json:"title" bson:"title"`       // A short, summary of the problem type. Written in english and readable for engineers (usually not suited for non technical stakeholders and not localized).
	Status   int      `json:"status" bson:"status"`     // The HTTP status code generated by the origin server for this occurrence of the problem. 100–599.
	Detail   string   `json:"detail" bson:"detail"`     // A human readable explanation specific to this occurrence of the problem.
	Details  []string `json:"details" bson:"details"`   // A list of human readable explanation specific to this occurrence of the problem.
	Instance string   `json:"instance" bson:"instance"` // An absolute URI that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
}

/*

Database code.

*/

// func dbReset () {}
// func dbWrite () {}
// func dbQuery () {}

func dbInit() *mgo.Session {
	session, err := mgo.Dial(secrets.Mongo())
	if err != nil {
		panic(err)
	}
	return session
}

func dbAddUser(db *mgo.Session, user User) error {
	c := db.DB("chatty").C("users")
	count, err := c.Find(bson.M{"username": user.Username}).Limit(1).Count()
	if err != nil {
		return err
	}
	if count > 0 {
		return fmt.Errorf("User %s already exists.", user.Username)
	}
	return c.Insert(user)
}

func dbItemsInCollection(db *mgo.Session, collection string) (interface{}, error) {
	c := db.DB("chatty").C(collection)
	switch {
	case collection == "users":
		user := User{}
		find := c.Find(bson.M{})
		items := find.Iter()
		response := []User{}
		for items.Next(&user) {
			response = append(response, user)
		}
		return response, nil
	case collection == "messages":
		message := Message{}
		find := c.Find(bson.M{})
		items := find.Iter()
		response := []Message{}
		for items.Next(&message) {
			response = append(response, message)
		}
		return response, nil
	}
	return nil, errors.New("Valid collections are: users, messages.")
}

/*

Controller code.

*/

type Controller struct {
	DB *mgo.Session
}

func NewController(db *mgo.Session) *Controller {
	return &Controller{
		DB: db,
	}
}

func (c *Controller) ListUsers(response http.ResponseWriter, request *http.Request) {
	items, err := dbItemsInCollection(c.DB, "users")
	if err != nil {
		log.Println(err)
	}
	response.Header().Set("Content-Type", "application/json")
	json.NewEncoder(response).Encode(items)
}

func (c *Controller) NewUser(response http.ResponseWriter, request *http.Request) {
}

func (c *Controller) GetUser(response http.ResponseWriter, request *http.Request) {
}

func (c *Controller) NewMessage(response http.ResponseWriter, request *http.Request) {
}

func (c *Controller) GetMessages(response http.ResponseWriter, request *http.Request) {
}

func (c *Controller) GetMessage(response http.ResponseWriter, request *http.Request) {
}

/*

Main.

*/

func main() {

	d := dbInit()
	defer d.Close()

	ctrl := NewController(d)

	mux := http.NewServeMux()
	mux.HandleFunc("/listusers", ctrl.ListUsers)   // List all users.
	mux.HandleFunc("/users", ctrl.NewUser)         // New user.
	mux.HandleFunc("/users/", ctrl.GetUser)        // Get user by username.
	mux.HandleFunc("/messages", ctrl.NewMessage)   // New message.
	mux.HandleFunc("/messages/", ctrl.GetMessages) // Get messages to user.
	mux.HandleFunc("/message/", ctrl.GetMessage)   // Get message by id.

	if err := http.ListenAndServe(":8000", mux); err != nil {
		log.Fatal(err)
	}

}

/*

Operations:

Create a user.
POST /users
{
	"name": "Peter Gibbons",
	"username": "peter.gibbons"
  }
Responses:
201 - The user object representation. application/json.
400 - The user object is bad formatted, missing attributes or has invalid values. application/problem+json.
409 - The username is already taken by another user. application/problem+json.
default - Unexpected Error. application/problem+json.

Get a user by id.
GET /users/{id}
Responses:
200 - The user object representation. application/json.
404 - The user was not found. application/problem+json.
default - Unexpected Error. application/problem+json.

Send message from one user to another.
POST /messages
{
	"from": "string",
	"to": "string",
	"body": "string"
}
Responses:
201 - The message object representation. application/json.

List the messages a user has received.
GET /messages?to={user}
Responses:
200 - The message listing representation. application/json.
400 - The request is missing required attributes. application/problem+json.
404 - The user was not found. application/problem+json.
default - Unexpected Error. application/problem+json.

Get a message by id.
GET /message/{id}
Responses:
200 - The message object representation. application/json.
404 - The message was not found. application/problem+json.
default - Unexpected Error. application/problem+json.

*/
