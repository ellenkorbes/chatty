package main

import (
	"encoding/json"
	"errors"
	"log"
	"net/http"
	"path"
	"regexp"
	"time"

	"github.com/ellenkorbes/chatty/secrets"

	mgo "gopkg.in/mgo.v2"
	"gopkg.in/mgo.v2/bson"
)

/*

Types.

*/

type User struct {
	ID        bson.ObjectId `json:"id"        bson:"_id,omitempty"` // The unique indentifier of the object. Read only.
	Budget    int           `json:"budget"    bson:"budget"`        // The remaining budget to send messages. Read only.
	Name      string        `json:"name"      bson:"name"`          // The human readable name of the user.
	Username  string        `json:"username"  bson:"username"`      // The unique name of the user. '^[a-z][a-z_\.\-0-9]*$'.
	CreatedAt time.Time     `json:"createdAt" bson:"createdAt"`     // The UTC date and time user has been created. Read only.
	UpdatedAt time.Time     `json:"updatedAt" bson:"updatedAt"`     // The UTC date and time user has been updated. Read only.
}

// Dates should follow: 2018-02-19T19:23:57.943Z
// time.Parse(time.RFC3339, "2006-01-02T15:04:05Z")

type Messages struct {
	Entries []Message `json:"messages" bson:"messages"`
}

type Message struct {
	ID     bson.ObjectId `json:"id"      bson:"_id,omitempty"` // The unique indentifier of the object. Read only.
	From   string        `json:"from"    bson:"from"`          // The sender user id.
	To     string        `json:"to"      bson:"to"`            // The recipient user id.
	Body   string        `json:"body"    bson:"body"`          // The message body content. Length: 1–280.
	SentAt time.Time     `json:"sentAt"  bson:"sentAt"`        // The UTC date and time message was sent. Read only.
}

type Problem struct {
	Type     string   `json:"type" bson:"type"`         // An absolute URI that identifies the problem type. When dereferenced, it SHOULD provide human-readable documentation for the problem type (e.g., using HTML).
	Title    string   `json:"title" bson:"title"`       // A short, summary of the problem type. Written in english and readable for engineers (usually not suited for non technical stakeholders and not localized).
	Status   int      `json:"status" bson:"status"`     // The HTTP status code generated by the origin server for this occurrence of the problem. 100–599.
	Detail   string   `json:"detail" bson:"detail"`     // A human readable explanation specific to this occurrence of the problem.
	Details  []string `json:"details" bson:"details"`   // A list of human readable explanation specific to this occurrence of the problem.
	Instance string   `json:"instance" bson:"instance"` // An absolute URI that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
}

/*

Database code.

*/

// func dbReset () {}
// func dbWrite () {}
// func dbQuery () {}

func dbInit() *mgo.Session {
	session, err := mgo.Dial(secrets.Mongo())
	if err != nil {
		panic(err)
	}
	return session
}

func dbAddUser(db *mgo.Session, user User) error {
	c := db.DB("chatty").C("users")
	count, err := c.Find(bson.M{"username": user.Username}).Limit(1).Count()
	if err != nil {
		return err
	}
	if count > 0 {
		return errors.New("409")
	}
	return c.Insert(user)
	// TODO: look into mgo.IsDup(err) func
}

func dbGetUser(db *mgo.Session, user string) (User, error) {
	data := User{}
	err := db.DB("chatty").C("users").Find(bson.M{"username": user}).One(&data)
	if err != nil {
		return data, err
	}
	return data, nil
}

func dbAddMessage(db *mgo.Session, message Message) error {
	c := db.DB("chatty").C("messages")
	return c.Insert(message)
}

func dbGetMessage(db *mgo.Session, id bson.ObjectId) (Message, error) {
	data := Message{}
	err := db.DB("chatty").C("messages").FindId(id).One(&data)
	if err != nil {
		return data, err
	}
	return data, nil
}

func dbDecreaseBudget(db *mgo.Session, sender User) error {
	userCheck := User{}
	budget := mgo.Change{
		Update:    bson.M{"$inc": bson.M{"budget": -1}, "$set": bson.M{"updatedAt": time.Now()}},
		ReturnNew: true,
	}
	_, err := db.DB("chatty").C("users").Find(bson.M{"username": sender.Username}).Apply(budget, &userCheck)
	if err != nil {
		return err
	}
	if sender.Budget-1 != userCheck.Budget {
		return errors.New("budget discrepancy")
	}
	return nil
}

func dbItemsInCollection(db *mgo.Session, collection string) (interface{}, error) {
	c := db.DB("chatty").C(collection)
	switch {
	case collection == "users":
		user := User{}
		find := c.Find(bson.M{})
		items := find.Iter()
		response := []User{}
		for items.Next(&user) {
			response = append(response, user)
		}
		return response, nil
	case collection == "messages":
		message := Message{}
		find := c.Find(bson.M{})
		items := find.Iter()
		response := []Message{}
		for items.Next(&message) {
			response = append(response, message)
		}
		return response, nil
	}
	return nil, errors.New("Valid collections are: users, messages.")
}

/*

Controller code.

*/

type Controller struct {
	DB *mgo.Session
}

func NewController(db *mgo.Session) *Controller {
	return &Controller{
		DB: db,
	}
}

func (c *Controller) ListAllUsers(response http.ResponseWriter, request *http.Request) {
	items, err := dbItemsInCollection(c.DB, "users")
	if err != nil {
		log.Println(err)
	}
	response.Header().Set("Content-Type", "application/json")
	json.NewEncoder(response).Encode(items)
}

func (c *Controller) ListMessages(response http.ResponseWriter, request *http.Request) {
	items, err := dbItemsInCollection(c.DB, "messages")
	if err != nil {
		log.Println(err)
	}
	response.Header().Set("Content-Type", "application/json")
	json.NewEncoder(response).Encode(items)
}

func (c *Controller) NewUser(response http.ResponseWriter, request *http.Request) {
	if request.Method != "POST" {
		http.Error(response, "Please use a POST request.", http.StatusBadRequest)
		log.Println("Non-POST /users request.")
		return
	}
	decoder := json.NewDecoder(request.Body)
	var newUser User
	err := decoder.Decode(&newUser)
	if err != nil {
		response.Header().Set("Content-Type", "application/problem+json")
		http.Error(response, "The user object is bad formatted, missing attributes or has invalid values.", http.StatusBadRequest)
		log.Println("JSON decoding error.", err)
		return
	}
	r, _ := regexp.Compile(`^[a-z][a-z_\.\-0-9]*$`)
	if !r.MatchString(newUser.Username) {
		response.Header().Set("Content-Type", "application/problem+json")
		http.Error(response, "The user object is bad formatted, missing attributes or has invalid values.", http.StatusBadRequest)
		log.Println("Regexp error.", err)
		return
	}
	if newUser.Name == "" {
		response.Header().Set("Content-Type", "application/problem+json")
		http.Error(response, "The user object is bad formatted, missing attributes or has invalid values.", http.StatusBadRequest)
		log.Println("Empty name field.", err)
		return
	}
	newUser.ID = bson.NewObjectId()
	newUser.Budget = 10
	newUser.CreatedAt = time.Now()
	newUser.UpdatedAt = time.Now()
	err = dbAddUser(c.DB, newUser)
	if err != nil {
		response.Header().Set("Content-Type", "application/problem+json")
		if err.Error() == "409" {
			http.Error(response, "The username is already taken by another user.", http.StatusConflict)
			log.Println("Username already taken.", err)
			return
		} else {
			http.Error(response, "Unexpected Error.", http.StatusInternalServerError)
			log.Println("Unknown error in dbAddUser call.", err)
			return
		}
	}
	check, err := dbGetUser(c.DB, newUser.Username)
	if err != nil {
		response.Header().Set("Content-Type", "application/problem+json")
		http.Error(response, "Unexpected Error.", http.StatusInternalServerError)
		log.Println("Error in dbGetUser.", err)
		return
	}
	response.Header().Set("Content-Type", "application/json")
	response.WriteHeader(http.StatusCreated)
	json.NewEncoder(response).Encode(check)
}

func (c *Controller) GetUser(response http.ResponseWriter, request *http.Request) {
	if request.Method != "GET" {
		http.Error(response, "Please use a GET request.", http.StatusBadRequest)
		log.Println("Non-GET /users/ request.")
		return
	}
	user := path.Base(request.URL.Path)
	query, err := dbGetUser(c.DB, user)
	if err != nil {
		if err.Error() == "not found" {
			response.Header().Set("Content-Type", "application/problem+json")
			http.Error(response, "The user was not found.", http.StatusNotFound)
			log.Println("Error in dbGetUser.", err)
			return
		} else {
			response.Header().Set("Content-Type", "application/problem+json")
			http.Error(response, "Unexpected Error.", http.StatusInternalServerError)
			log.Println("Error in dbGetUser.", err)
			return
		}
	}
	response.Header().Set("Content-Type", "application/json")
	json.NewEncoder(response).Encode(query)
}

func (c *Controller) NewMessage(response http.ResponseWriter, request *http.Request) {
	if request.Method != "POST" {
		http.Error(response, "Please use a POST request.", http.StatusBadRequest)
		log.Println("Non-POST /users request.")
		return
	}
	decoder := json.NewDecoder(request.Body)
	var newMessage Message
	err := decoder.Decode(&newMessage)
	if err != nil {
		response.Header().Set("Content-Type", "application/problem+json")
		http.Error(response, "The user object is bad formatted, missing attributes or has invalid values.", http.StatusBadRequest)
		log.Println("JSON decoding error.", err)
		return
	}
	if newMessage.To == "" || newMessage.From == "" || newMessage.Body == "" {
		response.Header().Set("Content-Type", "application/problem+json")
		errors := ""
		switch {
		case newMessage.To == "":
			errors += "Message sender is empty. "
		case newMessage.From == "":
			errors += "Message recipient is empty. "
		case newMessage.Body == "":
			errors += "Message has no content. "
		}
		http.Error(response, errors, http.StatusBadRequest)
		log.Println(errors, err)
	}
	sender, err := dbGetUser(c.DB, newMessage.From)
	if err != nil {
		if err.Error() == "not found" {
			response.Header().Set("Content-Type", "application/problem+json")
			http.Error(response, "Sender user not found.", http.StatusNotFound)
			log.Println("Sender user not found.", err)
			return
		} else {
			response.Header().Set("Content-Type", "application/problem+json")
			http.Error(response, "Unexpected error verifying sender.", http.StatusInternalServerError)
			log.Println("Unexpected error verifying sender.", err)
			return
		}
	} else if sender.Budget < 1 {
		response.Header().Set("Content-Type", "application/problem+json")
		http.Error(response, "User budget exceeded.", http.StatusUnauthorized)
		log.Println("User budget exceeded.", err)
		return
	}
	_, err = dbGetUser(c.DB, newMessage.To)
	if err != nil {
		if err.Error() == "not found" {
			response.Header().Set("Content-Type", "application/problem+json")
			http.Error(response, "Recipient user not found.", http.StatusNotFound)
			log.Println("Recipient user not found.", err)
			return
		} else {
			response.Header().Set("Content-Type", "application/problem+json")
			http.Error(response, "Unexpected error verifying recipient.", http.StatusInternalServerError)
			log.Println("Unexpected error verifying recipient.", err)
			return
		}
	}
	newMessage.ID = bson.NewObjectId()
	newMessage.SentAt = time.Now()
	dbAddMessage(c.DB, newMessage)
	if err != nil {
		http.Error(response, "Unexpected Error.", http.StatusInternalServerError)
		log.Println("Unknown error in dbAddMessage call.", err)
		return
	}
	check, err := dbGetMessage(c.DB, newMessage.ID)
	if err != nil {
		response.Header().Set("Content-Type", "application/problem+json")
		http.Error(response, "Unexpected Error.", http.StatusInternalServerError)
		log.Println("Error in dbGetMessage.", err)
		return
	}
	err = dbDecreaseBudget(c.DB, sender)
	if err != nil {
		if err.Error() == "budget discrepancy" {
			log.Println("Budget discrepancy.", err)
		} else {
			log.Println("Unknown error in dbDecreaseBudget call.", err)
		}
	}
	response.Header().Set("Content-Type", "application/json")
	response.WriteHeader(http.StatusCreated)
	json.NewEncoder(response).Encode(check)
}

func (c *Controller) GetMessages(response http.ResponseWriter, request *http.Request) {
}

func (c *Controller) GetMessage(response http.ResponseWriter, request *http.Request) {
}

/*

Main.

*/

func main() {

	d := dbInit()
	defer d.Close()
	ctrl := NewController(d)
	mux := http.NewServeMux()
	mux.HandleFunc("/listusers", ctrl.ListAllUsers) // List all users.
	mux.HandleFunc("/listmsg", ctrl.ListMessages)   // List all messages.
	mux.HandleFunc("/users", ctrl.NewUser)          // New user.
	mux.HandleFunc("/users/", ctrl.GetUser)         // Get user by username.
	mux.HandleFunc("/messages", ctrl.NewMessage)    // New message.
	mux.HandleFunc("/messages/", ctrl.GetMessages)  // Get messages to user.
	mux.HandleFunc("/message/", ctrl.GetMessage)    // Get message by id.

	if err := http.ListenAndServe(":8000", mux); err != nil {
		log.Fatal(err)
	}

}

/*

Operations:

Create a user.
POST /users
{
	"name": "Peter Gibbons",
	"username": "peter.gibbons"
  }
Responses:
201 - The user object representation. application/json.
400 - The user object is bad formatted, missing attributes or has invalid values. application/problem+json.
409 - The username is already taken by another user. application/problem+json.
default - Unexpected Error. application/problem+json.

Get a user by id.
GET /users/{id}
Responses:
200 - The user object representation. application/json.
404 - The user was not found. application/problem+json.
default - Unexpected Error. application/problem+json.

Send message from one user to another.
POST /messages
{
	"from": "string",
	"to": "string",
	"body": "string"
}
Responses:
201 - The message object representation. application/json.

List the messages a user has received.
GET /messages?to={user}
Responses:
200 - The message listing representation. application/json.
400 - The request is missing required attributes. application/problem+json.
404 - The user was not found. application/problem+json.
default - Unexpected Error. application/problem+json.

Get a message by id.
GET /message/{id}
Responses:
200 - The message object representation. application/json.
404 - The message was not found. application/problem+json.
default - Unexpected Error. application/problem+json.

*/
